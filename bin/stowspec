#!/bin/sh
:; #-*- mode: nendo; syntax: scheme -*-;;
:; exec /usr/local/bin/nendo $0 $*

(define debug-print-length 1024)
(define pp pretty-print)

(define archive-file-pattern "([a-zA-Z].*)")
(define initfile-path   (File.expand_path "~/.stowspec"))
(define stow-home       (File.expand_path "~/stowspec"))
(define stow-target "/usr/local/stow")
(define stow-bin    "/usr/local/bin")
(define stow-lib    "/usr/local/lib")
(define stow-temp   "/tmp/stowspec")
(define stow-program
  (let1 lst
      (filter-map
       (lambda (prog)
         (let ((path1 (+ "/usr/bin/" prog))
               (path2 (+ "/usr/local/bin/" prog)))
           (if (File.exist? path1)
               path1
               (if (File.exist? path2)
                   path2))))
       '("xstow" "stow"))
      (if (< 0 (length lst))
          (car lst)
          (begin
            (STDERR.puts "Error: not found the stow program. (or xstow) ")
            (exit 1)))))

;; `regex' is a string ( not a regex object )
;; returns ( $0-string  $1-string  $2-string  $3-string ... )
(define (regex-match regex str)
  (let1 matchdata (str.match regex)
    (if matchdata
        (matchdata.to_a.to_list)
        nil)))

;; test
;;(regex-match "^[a-z]+$" "abc")
;;(regex-match "^([a-z]+)([0-9]+)$" "abc123")


(define (display-help)
  (print "")
  (print "Usage: ")
  (print "  1. stowspec [enable] number      ... enable  program. (rewtow -R)")
  (print "  2. stowspec disable  number      ... disable program. (rewtow -D)")
  (print "  3. stowspec [URL of tar.gz]      ... fetch, setup specfile, build program.")
  (print "  4. stowspec tar.gz               ... setup specfile, build program.")
  (print "  5. stowspec                      ... list up installed program list.")
  (print ""))


(require "digest/md5")

(define (exec-sh script)
  (let* ((digest (Digest::MD5.hexdigest script))
         (tmpfile (sprintf "/tmp/stowspec_script.%s.sh" digest)))
    (with-open
     tmpfile
     (lambda (f)
       (f.puts script))
     "w")
    (printf "---BEGIN---(%s)\n" tmpfile)
    (.system (+ "bash " tmpfile))
    (print "---END---")
    (File.delete tmpfile)))


(define (tgz-to-name tgz)
  (cond
   ((regex-match (+ "^.+[/]" archive-file-pattern "(.tar.gz|.tgz|.tar.bz2)$") tgz)
    => second)
   ((regex-match (+ "^"   archive-file-pattern "(.tar.gz|.tgz|.tar.bz2)$") tgz)
    => second)
   (else
    nil)))

;; test
(when false
  (list
   (tgz-to-name "abc-1.2.3.tar.gz")
   (tgz-to-name "abc-1.2.3.tar.bz2")
   (tgz-to-name "abc-1.2.3.tgz")
   (tgz-to-name "file.txt")
   (tgz-to-name "http://ftp.gnu.org/gnu/wget/wget-1.9.tar.gz")
   ))


(define (get-project-basename name-and-ver)
  (cond
   ((regex-match (+ "^([A-Za-z0-9_-]+)[_-][0-9]+") name-and-ver)
    => second)
   (else
    "???")))

;; test
(when false
  (list
   (get-project-basename "abc-1.2.3.tar.gz")
   (get-project-basename "abc-1.2.3.tar.bz2")
   (get-project-basename "abc-1.2.3.tgz")
   (get-project-basename "file.txt")
   (get-project-basename "wget-1.9.tar.gz")
   (get-project-basename "w3m-0.5.2")
   (get-project-basename "emacs-w3m-20081218-CVS")
   (get-project-basename 
    (tgz-to-name "http://ftp.gnu.org/gnu/wget/wget-1.9.tar.gz"))
   ))

(define (get-envs)
  (let* ((pwd (ENV.fetch "PWD"))
         (in-project
          (cond
           ((regex-match (+ "^" stow-home "/" archive-file-pattern "$") pwd)
            => second)
           (else
            nil))))
    `(
      (pwd         . ,pwd)                  ;; pwd
      (home        . ,(ENV.fetch "HOME"))   ;; "/home/xxxx/"
      (stow-home   . ,stow-home)            ;; "/home/xxxx/stowspec"
      (target      . ,stow-target)          ;; "/usr/local/stow"
      (bin         . ,stow-bin)             ;; "/usr/local/bin"
      (lib         . ,stow-lib)             ;; "/usr/local/lib"
      (temp        . ,stow-temp)            ;; "/tmp/stowspec"
      (project     . ,in-project)           ;; nil or "aaaa-1.2.3.tar.gz"
      )))


(define (get-curdir-info envs)
  (let1 pwd (assq-ref 'pwd  envs)
    (cond
     ((assq-ref 'project envs)
      => (lambda (x)
           `(specdir . x)))
     (else
      `(other . "")))))


(define assoc-to-local
  (macro (_assoc name)
    `(,name (assq-ref (quote ,name) ,_assoc))))

;; test
(when false
  (let1 _aaa '((filename . "FILENAME")
               (projname . "PROJNAME")
               (url      . nil))
    (pretty-print
     (macroexpand
      '(let
           (
            (assoc-to-local _aaa filename)
            (assoc-to-local _aaa projname)))))
    (let
        (
         (assoc-to-local _aaa filename)
         (assoc-to-local _aaa projname))
      (+ filename ":" projname))))
      

(define (gen-script envs project-envs spec)
  (define (echo str)
    (string-join
     (list
      (sprintf "echo \" \" ============================================================")
      (sprintf "echo \" \" [[ %s ]]\n %s" str str)
      (sprintf "echo \" \" ============================================================"))
     "\n"))
  (define (pass str) str)

  (let* ((_ (append envs project-envs))
         (assoc-to-local _ projname)
         (assoc-to-local _ projpath)
         (assoc-to-local _ arc)
         (assoc-to-local _ workdir)
         (assoc-to-local _ url)
         (url (if (null? url)
                  #f
                  url)))
    (begin
      `(
        (store . ,(string-join
                   (list
                    (sprintf "mkdir -p %s" projpath)
                    (if url
                        (echo (sprintf "wget -O %s/%s %s"      projpath arc url))
                        (pass (sprintf "/bin/cp %s %s"         arc projpath)))
                    (sprintf "cd %s" projpath)
                    "")
                   "\n"))
        (build . ,(string-join
                   (append
                    (if (not (File.exist? (+ "./" arc)))
                        (if url
                            (list
                             (pass (sprintf "echo file [%s] was not found, so, I fetch it again." arc url))
                             (echo (sprintf "wget -O ./%s %s" arc url)))
                            (list
                             (pass (sprintf "echo file [%s] was not found, so, I try to get from ~/Downloads" arc))
                             (echo (sprintf "/bin/cp ~/Downloads/%s ." arc))))
                        '())
                    (list
                     (sprintf "if [ ! -e \"./%s\" ] ; then " arc)
                     (sprintf "  echo file [%s] was not found." arc)
                     (sprintf "  exit 1 ")
                     (sprintf "fi")
                     (sprintf "export TMPDIR=/tmp")
                     (sprintf "/bin/rm -rf %s/%s" workdir projname)
                     (sprintf "mkdir -p %s" workdir)
                     (sprintf "/bin/cp -f %s %s" arc workdir)
                     (sprintf "if [ ! -z \"`ls -1 | grep .patch`\" ] ; then")
                     (sprintf "  /bin/cp -f *.patch %s" workdir)
                     (sprintf "fi")
                     (sprintf "cd %s" workdir)
                     (sprintf "tar zxf %s" arc)
                     (sprintf "for i in `ls -1 | grep .patch` ;")
                     (sprintf "do")
                     (echo (sprintf "  patch -p 0 -i ${i}"))
                     (sprintf "done")
                     (sprintf "cd ./%s"    projname)
                     (assq-ref 'conf       spec)
                     (echo (assq-ref 'make       spec))
                     (echo (assq-ref 'install    spec))
                     ""))
                   "\n"))
        (stowspec . ,(string-join
                      (list
                       (sprintf "cd %s" projpath)
                       "stowspec"
                       "")
                      "\n"))
        ))))


(define (get-dir-entries path)
  (filter
   (lambda (x)
     (not (or (x.match "[/]?[.]$")
              (x.match "[/]?[.][.]$")
              (x.match "^[.]"))))
   (to-list (Dir.entries path))))

;;(get-dir-entries "/usr/local/stow")


(define (get-linklist envs)
  (let* ((bin-path (assq-ref 'bin envs))
         (lib-path (assq-ref 'lib envs))
         (bin-list
          (append
           (map  (lambda (x) (+ bin-path "/" x))
                 (get-dir-entries bin-path))
           (map  (lambda (x) (+ lib-path "/" x))
                 (get-dir-entries lib-path)))))
    (filter-map
     (lambda (x)
       (when (File.symlink? x)
         (File.readlink x)))
     bin-list)))
  

;; check installed binary file by stow.
(define (binary-installed? envs linklist projname)
  (if (not projname)
      false
      ;; checking installed file counts.
      (find
       (lambda (x)
         (regex-match (+ "[/]" projname "[/]") x))
       linklist)))

(define (get-stowed-list envs)
  (let* ((projs    (get-dir-entries (assq-ref 'stow-home envs)))
         (stowed   (get-dir-entries (assq-ref 'target envs)))
         (all      (uniq (sort (append projs stowed))))
         (linklist (get-linklist envs))
         (cnt      0))
    (map
     (lambda (x)
       (let1 result
           (cons x
                 (list
                  (if (memv x stowed)
                      (if (binary-installed? envs linklist x) 'i false)
                      false)
                  (if (memv x stowed) 's false)
                  (if (memv x projs ) 'p false)
                  (get-project-basename x)
                  cnt))
         (begin
           (set! cnt (+ cnt 1))
           result)))
     all)))

(when false
  (get-stowed-list
   '(
     (pwd . "/Volumes/CaseSensitive/kiyoka/work/github/nendo/sample")
     (home . "/Users/kiyoka")
     (stow_home . "/Users/kiyoka/stowspec")
     (target . "/usr/local/stow")
     (bin . "/usr/local/bin")
     (temp . "/tmp/stowspec")
     (project))))


(define (stowed-list-to-tree lst)
  (let1 program-hash (make-hash-table)
    (for-each
     (lambda (x)
       (hash-table-push! program-hash (fifth x) x))
     (reverse lst))
    (reverse (hash-table->alist program-hash))))

;; test
(when false
  (stowed-list-to-tree 
   '(
     ("Gauche-0.8.14" false s p "Gauche" 0) ("Gauche-0.9" i s p "Gauche" 1) ("ImageMagick-6.6.0-10" false false p "ImageMagick" 2) ("apache-couchdb-0.9.2" false s p "apache-couchdb" 3) ("apel-10.7" false false p "apel" 4) ("bash-4.1" false s p "bash" 5) ("chibi-scheme-0.1" false false p "chibi-scheme" 6) ("chicken-4.4.0" false false p "chicken" 7) ("curl-7.20.0" false false p "curl" 8) ("ddskk-13.1" false false p "ddskk" 9) ("emacs-22.3" false false p "emacs" 10) ("emacs-23.1" false false p "emacs" 11) ("emacs-w3m-1.4.4" false false p "emacs-w3m" 12) ("emacs-w3m-20080127-CVS" false s p "emacs-w3m" 13) ("emacs-w3m-20081218-CVS" false false p "emacs-w3m" 14) ("emacs-w3m-20100322-CVS" false false p "emacs-w3m" 15) ("erlang_13.04" false false p "erlang" 16) ("gc-7.1" i s p "gc" 17) ("gdbm-1.8.3" i s p "gdbm" 18) ("git-1.6.2.4" false s p "git" 19) ("git-1.7.0.3" false s p "git" 20) ("git-1.7.0.4" i s p "git" 21) ("gmp-5.0.1" false s p "gmp" 22) ("guile-1.8.7" false false p "guile" 23) ("haml-2.2.22" false false p "haml" 24) ("llvm-2.6" false false p "llvm" 25) ("lookup-1.4.1" false false p "lookup" 26) ("mew-6.3" false false p "mew" 27) ("mosh-0.2.3" i s p "mosh" 28) ("ruby-1.4.0-jruby" false s p "ruby" 29) ("ruby-1.5.0.RC1-jruby" false s p "ruby" 30) ("ruby-1.8.7-p174" false s p "ruby" 31) ("ruby-1.9.1-p376" false s p "ruby" 32) ("ruby-1.9.1-p376-sandbox" i s p "ruby" 33) ("ruby-1.9.2-preview1" false s p "ruby" 34) ("ruby-refm-1.9.1-dynamic-20100329" false false p "ruby-refm" 35) ("simstring-1.0" false s p "simstring" 36) ("sinatra-1.0" false false p "sinatra" 37) ("subversion-16" false false p "subversion" 38) ("tinyscheme-1.39" false false p "tinyscheme" 39) ("tokyocabinet-1.4.42" false s p "tokyocabinet" 40) ("w3m-0.5.2" i s p "w3m" 41) ("wget-1.11.4" i s p "wget" 42) ("xstow-0.6.1-unstable" i s p "xstow" 43))
   )
  )
  
(define (listing stowed-list)
  (define (ox bool-val)
    (if bool-val "O" "-"))
  (define _format_h "       %-25s %10s %10s\n")
  (define _format_d "   %2d) %-25s %10s %10s\n")

  (print
   (apply +
          (cons
           (sprintf _format_h "       <name>" "<enabled>" "<installed>")
           (map
            (lambda (tree)
              (apply +
                     (cons
                      (sprintf " %s \n" (car tree))
                      (map
                       (lambda (x)
                         (sprintf _format_d
                                  (sixth x)
                                  (+ " " (first x))
                                  (ox (second x))
                                  (ox (third x))))
                       (cdr tree)))))
            (stowed-list-to-tree stowed-list))))))
    


(define (action-by-curdir envs)
  (define (load-specfile envs)
    (load "./specfile")
    (or stowspec
        (begin
          (STDERR.printf "Error: spec was not defined... please use (define-stowspec '(...)) form\n")
          (exit 1))))

  (define (do-build envs spec)
    (let1 project-envs (get-project-envs envs
                                         (assq-ref 'projname spec)
                                         (assq-ref 'arc      spec)
                                         (assq-ref 'url      spec))
      (exec-sh
       (assq-ref 'build (gen-script
                         envs
                         project-envs
                         spec)))))
  
  (let1 curdir-info (get-curdir-info envs)
    (cond
     ((eq? 'specdir (car curdir-info))
      ;; ----------
      ;; load specfile
      ;; ----------

      (let* ((spec (load-specfile envs))
             (_ (append envs spec))
             (assoc-to-local _ target)
             (assoc-to-local _ projname))
        ;; ----------
        ;; build!
        ;; ----------
        (if (not (File.exist? (+ target "/" projname)))
            (do-build envs spec)
            (begin
              (printf "Warning: [%s] was already built and installed. rebuild? [Y/n]\n" projname)
              (if (yes-or-no?)
                  (do-build envs spec)
                  (printf "Info: build [%s] was canceled. \n" projname))))))
     (else
      ;; ----------
      ;; show current stowed status
      ;; ----------
      (listing 
       (get-stowed-list envs))
      (print  "[stow-home]")
      (printf " cd %s\n" stow-home)))))


(define (get-project-envs envs projname arc url)
  (let1 projpath (+ (assq-ref 'stow-home envs) "/" projname)
    `(
      (projname . ,projname)
      (projpath . ,projpath)
      (workdir  . ,(sprintf "%s/%s" (assq-ref 'temp envs) projname))
      (arc      . ,arc)
      (url      . ,url)
      (specfile . ,(+ projpath "/specfile")))))


(define (yes-or-no?)
  (let1 ch (STDIN.getc)
    (if (nil? ch)
        #f
        (not (ch.chr.match "[nN]")))))

(define (action-by-keyword envs keyword number)
  (define (do-restow target delete-item restow-item)
    (let1 script (string-join
                  (list
                   (sprintf "cd %s" target)
                   (if (null? delete-item)
                       ""
                       (sprintf "%s -D %s" stow-program (car delete-item)))
                   (if (null? restow-item)
                       ""
                       (sprintf "%s -R %s" stow-program (car restow-item)))
                   "")
                  "\n")
      (exec-sh script)))
  
  (let1 keywords '("enable" "disable")
    (when (not (memv keyword keywords))
      (printf "Error: usable keywords are (%s) " (string-join keywords " or "))
      (display-help)
      (exit 1)))

  (let* ((delete-action (eq? "disable" keyword))
         (lst (get-stowed-list envs))
         ;; ----------
         ;; search the number in list
         ;; ----------
         (found
          (filter
           (lambda (x)
             (= number (sixth x)))
           lst)))
    (if (null? found)
        (begin
          (printf "Error: selected number [%d] was not found...\n" number)
          (exit 1))
        (let* ((basename (fifth (car found)))
               (tree (stowed-list-to-tree lst))
               (selection (assv-ref basename tree)))
          (let ((delete-item
                 (filter-map
                  (lambda (x)
                    (if (= 'i (second x))
                        (car x)
                        nil))
                  selection))
                (restow-item
                 (filter-map
                  (lambda (x)
                    (if (and (= 's (third x))
                             (= number (sixth x)))
                        (car x)
                        nil))
                  selection)))
            (cond
             ((null? restow-item)
              (printf "Error: selected number [%d] was not installed yet. \n" number)
              (exit 1))
             (delete-action
              (do-restow (assq-ref 'target envs) delete-item '()))
             ((equal? delete-item restow-item)
              (printf "Info: force restow [%s] again? [Y/n]\n" (car restow-item))
              (if (yes-or-no?)
                  (do-restow (assq-ref 'target envs) delete-item restow-item)
                  (begin
                    (printf "Info: `restow -R' was canceled. \n" (car restow-item))
                    (exit 0))))
             (else
              (do-restow (assq-ref 'target envs) delete-item restow-item))))))))


(define (action-by-arg envs argv)
  (let* ((m1 (regex-match (+ "^http://.+/" archive-file-pattern "$") (car argv)))
         (m2 (regex-match (+ "^" archive-file-pattern "$") (car argv)))
         (url      (if m1 (car m1) nil))
         (arc      (if m1 (second m1)
                       (if m2 (car m2) nil))))
    (when (not (or m1 m2))
      (printf "Error: Please specify complete URL or local archive file name.\n")
      (display-help)
      (exit 1))
    (let* ((projname (or (tgz-to-name arc) ""))
           (project-envs (get-project-envs envs projname arc url))
           (assoc-to-local project-envs workdir)
           (assoc-to-local project-envs specfile)
           (assoc-to-local project-envs projpath))
      (if (or url arc)
          (begin
            (printf "url      = %s\n" url)
            (printf "arc      = %s\n" arc)
            (printf "projname = %s\n" projname)
            (printf "workdir  = %s\n" workdir)
            (printf "specfile = %s\n" specfile)
            (let* ((scripts  (gen-script envs project-envs '())))
              (exec-sh (assq-ref 'store scripts))
              (printf "Info: specfile = %s\n" specfile)
              (printf "cd %s\n" projpath)
              (with-open specfile
                         (lambda (f)
                           (f.puts ";;-*- mode: scheme; syntax: scheme -*-;;")
                           (f.puts "(define-stowspec '(")
                           (for-each
                            (lambda (x)
                              (f.puts (+ " " (write-to-string x))))
                            `((conf      .
                                         ,(string-join
                                           (list
                                            "if [ ! -e ./configure ] ; then"
                                            "  echo 'Error: stowspec supports ./configure script included tar ball only, sorry...'"
                                            "  exit 1"
                                            "fi"
                                            (sprintf "command='./configure --prefix=%s/%s' " (assq-ref 'target envs) projname)
                                            (sprintf "echo \" \" ============================================================")
                                            (sprintf "echo \" \" [[ ${command} ]]")
                                            (sprintf "echo \" \" ============================================================")
                                            "${command}"
                                            "")
                                           "\n"))
                              (make      . "make")
                              (install   . "make install")
                              (arc       . ,arc)
                              (url       . ,url)
                              (projname  . ,projname)))
                           (f.puts "))"))
                         "w")
              (exec-sh (assq-ref 'stowspec scripts))))
          (begin
            (print "Error: please specify url by argument.")
            (exit 1))))))
          
;; test
;;(action-by-arg '("a.tar.gz"))
;;(action-by-arg '("http://www.example.com/a.tar.gz"))


(define (main argv)
  (define (version-value version-str)
    (let1 ver
        (map
         to-i
         (to-list (version-str.split ".")))
      (+
       (* (first  ver) (* 1000 1000))
       (* (second ver) 1000)
       (third  ver))))
  
  ;; version check
  (when (< (version-value *nendo-version*) (version-value "0.3.1"))
    (printf "Error: Stowspec expects nendo %s.%s.%s or later version.\n" _first _second _third)
    (printf "       Installed nendo version is [%s]\n" *nendo-version*)
    (exit 1))

  ;; load dotfiles
  (if (File.exist? initfile-path)
      (load initfile-path))

  ;; branch by argument
  (let1 envs (get-envs)
    (case (length argv)
      ((0)
       (action-by-curdir envs))
      (else
       (cond
        ((regex-match "^[a-zA-Z]+$" (car argv))
         (action-by-keyword envs (car argv) (to-i (cadr argv))))
        ((regex-match "^[0-9]+$"    (car argv))
         (action-by-keyword envs "enable" (to-i (car argv))))
        (else
         (action-by-arg    envs argv)))))))


;; ----------------------------------------
;; utility for user's "specfile" file.
;; ----------------------------------------
(define stowspec nil)
(define (define-stowspec alist)
  (set! stowspec alist))
(define uname 
  (let1 f (IO.popen "uname" "r+")
    f.readline.chop))
